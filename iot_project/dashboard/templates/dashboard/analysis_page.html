{% extends 'base.html' %}
{% load static %}

{% block title %}Device Analysis - {{ device.name }}{% endblock %}

{% block head_extra %}
<!-- Chart.js for dynamic charts -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- REQUIRED for Chart.js time scale: https://www.chartjs.org/docs/latest/axes/timeseries.html#date-adapters -->
<script src="https://cdn.jsdelivr.net/npm/luxon@3.x/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.x/dist/chartjs-adapter-luxon.min.js"></script>

<!-- Google Fonts and Lucide Icons for consistency -->
<link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Orbitron:wght@400;500;700&display=swap"
    rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/lucide/0.263.1/lucide.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
<style>
    /* Merged CSS from homepage.html for animations and background */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    :root {
        /* IoT Theme Colors from homepage.html */
        --background: hsl(222, 47%, 4%);
        --foreground: hsl(210, 40%, 98%);
        --card: hsl(222, 47%, 8%);
        --card-foreground: hsl(210, 40%, 98%);
        --primary: hsl(195, 100%, 50%);
        /* Main accent blue */
        --primary-foreground: hsl(222, 47%, 4%);
        /* Text on primary */
        --secondary: hsl(260, 60%, 65%);
        /* Purple accent */
        --accent: hsl(180, 100%, 50%);
        /* Cyan accent */
        --muted: hsl(222, 47%, 12%);
        /* Muted background */
        --muted-foreground: hsl(215, 20%, 65%);
        /* Muted text */
        --border: hsl(222, 47%, 20%);
        --input: hsl(222, 47%, 12%);
        --destructive: hsl(0, 84%, 60%);
        /* Red for errors */
        --warning: hsl(40, 95%, 55%);
        /* Orange for warnings */

        /* Gradients */
        --gradient-primary: linear-gradient(135deg, var(--primary), var(--secondary));
        --gradient-cyber: linear-gradient(45deg, var(--primary), var(--accent));
        --gradient-glass: linear-gradient(135deg, hsla(222, 47%, 8%, 0.8), hsla(222, 47%, 12%, 0.4));

        /* Effects */
        --shadow-cyber: 0 0 30px hsla(195, 100%, 50%, 0.3);
        --shadow-glass: 0 8px 32px hsla(222, 47%, 4%, 0.3);
    }

    body {
        font-family: 'Inter', sans-serif;
        background: var(--background);
        color: var(--foreground);
        min-height: 100vh;
        overflow-x: hidden;
        position: relative;
    }

    /* Animated Background from homepage.html */
    body::before {
        content: '';
        position: fixed;
        inset: 0;
        background-image:
            radial-gradient(circle at 20% 80%, hsla(195, 100%, 50%, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, hsla(260, 60%, 65%, 0.1) 0%, transparent 50%),
            linear-gradient(0deg, hsla(195, 100%, 50%, 0.08) 1px, transparent 1px),
            linear-gradient(90deg, hsla(195, 100%, 50%, 0.08) 1px, transparent 1px);
        background-size: 100% 100%, 100% 100%, 60px 60px, 60px 60px;
        background-position: 0% 0%, 0% 0%, 0 0, 0 0;
        opacity: 0.9;
        z-index: -2;
        animation: subtle-gradient-shift 20s ease-in-out infinite alternate;
    }

    .animated-grid {
        position: absolute;
        inset: 0;
        background-image:
            linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
        background-size: 50px 50px;
        z-index: -1;
        animation: pan-grid 60s linear infinite;
        opacity: 0.5;
    }

    @keyframes subtle-gradient-shift {
        0% {
            background-position: 0% 0%, 0% 0%, 0 0, 0 0;
        }

        100% {
            background-position: 100% 100%, 100% 100%, 60px 60px, 60px 60px;
        }
    }

    @keyframes pan-grid {
        0% {
            background-position: 0 0;
        }

        100% {
            background-position: -50px -50px;
        }
    }

    /* Existing device_detail.html styles (adjusted for the new theme) */
    h2.text-light {
        font-family: 'Orbitron', sans-serif;
        background: linear-gradient(90deg, var(--primary), var(--secondary));
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 8px hsla(195, 100%, 50%, 0.5);
        font-weight: 700;
    }

    .card {
        background-color: var(--card);
        /* Match homepage card color */
        color: var(--card-foreground);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        overflow: hidden;
        /* For rounded corners on chart */
    }

    .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4), 0 0 15px var(--primary);
    }

    .card-body {
        padding: 1.5rem;
    }

    .card-title {
        font-family: 'Orbitron', sans-serif;
        font-size: 1.5rem;
        color: var(--primary);
        text-shadow: 0 0 5px hsla(195, 100%, 50%, 0.3);
    }

    .badge.bg-success {
        background-color: hsla(120, 100%, 50%, 0.8) !important;
        box-shadow: 0 0 5px hsla(120, 100%, 50%, 0.5);
    }

    .badge.bg-danger {
        background-color: hsla(0, 84%, 60%, 0.8) !important;
        box-shadow: 0 0 5px hsla(0, 84%, 60%, 0.5);
    }

    .card-footer {
        background-color: var(--muted);
        border-top: 1px solid var(--border);
        padding: 1rem 1.5rem;
        color: var(--muted-foreground);
        font-size: 0.875rem;
    }

    /* Chart Canvas Styling */
    .chart-container {
        position: relative;
        height: 300px;
    }

    /* Table Styling */
    .data-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1.5rem;
        font-size: 0.9rem;
        text-align: left;
    }

    .data-table th,
    .data-table td {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid var(--border);
    }

    .data-table th {
        color: var(--primary);
        font-weight: 500;
        text-transform: uppercase;
    }

    .data-table tbody tr:hover {
        background-color: hsla(222, 47%, 12%, 0.5);
    }

    /* Additional styling for elements */
    .text-primary {
        color: var(--primary) !important;
    }

    .text-info {
        color: var(--accent) !important;
    }

    .bg-dark {
        background-color: var(--card) !important;
    }

    .text-light {
        color: var(--foreground) !important;
    }

    .border-secondary {
        border-color: var(--border) !important;
    }

    .btn-primary {
        background: var(--gradient-primary) !important;
        border: none !important;
        transition: all 0.3s ease;
    }

    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), 0 0 10px var(--primary);
    }

    .btn-danger {
        background-color: var(--destructive) !important;
        border-color: var(--destructive) !important;
        transition: all 0.3s ease;
    }

    .btn-danger:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), 0 0 10px var(--destructive);
    }

    /* Animation for the chart area */
    .chart-card {
        animation: fadeInScale 1s ease-out;
    }

    @keyframes fadeInScale {
        from {
            opacity: 0;
            transform: scale(0.98);
        }

        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    /* Add this to your style block or CSS file */
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translate3d(0, 40px, 0);
        }

        to {
            opacity: 1;
            transform: translate3d(0, 0, 0);
        }
    }

    .animated {
        animation-duration: 1s;
        animation-fill-mode: both;
    }

    .fade-in-up {
        animation-name: fadeInUp;
    }

    .theme-alert {
        background: var(--card);
        border: 1px solid var(--primary);
        color: var(--foreground);
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 0 10px rgba(var(--primary-rgb), 0.5);
        /* Add a glowing effect */
        transition: box-shadow 0.3s ease-in-out;
    }

    .theme-alert:hover {
        box-shadow: 0 0 20px rgba(var(--primary-rgb), 0.8);
    }

    .theme-alert h4 {
        color: var(--primary);
        /* Highlight the heading */
    }

    /* Specific styles for the Suggestions box */
    .suggestions-box {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        padding: 1.5rem;
        box-shadow: var(--shadow-glass);
        margin-top: 2rem;
        /* Set a fixed height that aligns with the graph, e.g., graph height + header/footer padding */
        height: 510px;
        /* Adjust this value to match your graph's height + card-body padding */
        display: flex;
        /* Use flexbox for internal layout */
        flex-direction: column;
        /* Stack content vertically */
    }

    .suggestions-box h5 {
        font-family: 'Orbitron', sans-serif;
        color: var(--primary);
        margin-bottom: 1rem;
        flex-shrink: 0;
        /* Prevent title from shrinking */
    }

    /* Make the suggestions list itself scrollable */
    #suggestionsList {
        overflow-y: auto;
        /* Enable vertical scrolling */
        flex-grow: 1;
        /* Allow it to take up available space */
        padding-right: 10px;
        /* Add some padding for the scrollbar */
    }

    /* Custom scrollbar for better aesthetics (optional) */
    #suggestionsList::-webkit-scrollbar {
        width: 8px;
    }

    #suggestionsList::-webkit-scrollbar-track {
        background: var(--muted);
        border-radius: 10px;
    }

    #suggestionsList::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 10px;
        border: 2px solid var(--muted);
    }

    #suggestionsList::-webkit-scrollbar-thumb:hover {
        background: var(--accent);
    }

    .suggestion-item {
        display: flex;
        align-items: flex-start;
        margin-bottom: 0.75rem;
        gap: 0.5rem;
    }

    .suggestion-icon {
        flex-shrink: 0;
        color: var(--accent);
        /* Cyan for icons */
        width: 1.2rem;
        height: 1.2rem;
        margin-top: 0.2rem;
        /* Align icon with text */
    }

    .suggestion-text {
        color: var(--foreground);
        font-size: 0.95rem;
        line-height: 1.5;
    }

    .suggestion-text strong {
        color: var(--primary);
        /* Highlight key phrases */
    }
</style>
{% endblock %}

{% block content %}
<div class="animated-grid"></div>
<h2 class="mb-4 text-light">{{ device.name }} ({{ device.get_device_type_display }}) - Analysis</h2>

<div class="row">
    <div class="col-lg-8 mb-4">
        <div class="card shadow-lg bg-dark text-light border-secondary">
            <div class="card-body">
                <h5 class="card-title text-primary">Sensor Data Trends (Last 24 Hours)</h5>
                {# Removed duration selector as per user's request to keep UI #}
                <div style="position: relative; height: 400px; width: 100%;">
                    <canvas id="sensorDataChart"></canvas>
                </div>
            </div>
            <div class="card-footer text-center">
                <small>Graphs showing historical sensor readings with anomaly detection and future predictions.</small>
            </div>
        </div>
    </div>

    <div class="col-lg-4 mb-4">
        <div class="suggestions-box">
            <h5 class="card-title">Intelligent Suggestions</h5>
            <div id="suggestionsList">
                <div class="suggestion-item">
                    <svg class="suggestion-icon lucide lucide-lightbulb">
                        <path
                            d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 3c0 1.8.7 3.3 1.5 4.5 1 .8 1.5 2.1 1.5 3.5" />
                        <line x1="9" x2="11" y1="20" y2="20" />
                        <line x1="12" x2="12" y1="17" y2="20" />
                        <line x1="13" x2="15" y1="20" y2="20" />
                        <path d="M12 20v2H8" />
                        <path d="M16 20v2H12" />
                    </svg>
                    <p class="suggestion-text">Analyzing your recent **data** for insights...</p>
                </div>
                <!-- Suggestions will be dynamically added here by JavaScript -->
            </div>
        </div>
    </div>
</div>

<div class="row mt-4">
    <div class="col-12">
        <div class="card shadow-lg bg-dark text-light border-secondary">
            <div class="card-body">
                <h5 class="card-title text-primary">Raw Data Log (Last {{ sensor_data_entries|length }} Readings)</h5>
                <div class="table-responsive" style="max-height: 400px; overflow-y: auto;">
                    <table class="table table-dark table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Timestamp</th>
                                {% if device.device_type == 'power_monitor' %}
                                <th>Voltage (V)</th>
                                <th>Current (A)</th>
                                <th>Power (W)</th>
                                <th>Energy (kWh)</th>
                                <th>Frequency (Hz)</th>
                                <th>PF</th>
                                <th>Relay State</th>
                                {% elif device.device_type == 'water_level' %}
                                <th>Water Level (%)</th>
                                {% else %}
                                <th>Raw Data</th>
                                {% endif %}
                            </tr>
                        </thead>
                        <tbody>
                            {# Loop through data_entry objects; .data is already a dictionary if JSONField #}
                            {% for data_entry in sensor_data_entries %}
                            <tr>
                                <td>{{ data_entry.timestamp|date:"Y-m-d H:i:s" }}</td>
                                {% if device.device_type == 'power_monitor' %}
                                <td>{{ data_entry.data.voltage|floatformat:2|default:"N/A" }}</td>
                                <td>{{ data_entry.data.current|floatformat:2|default:"N/A" }}</td>
                                <td>{{ data_entry.data.power|floatformat:2|default:"N/A" }}</td>
                                <td>{{ data_entry.data.energy|floatformat:2|default:"N/A" }}</td>
                                <td>{{ data_entry.data.frequency|floatformat:2|default:"N/A" }}</td>
                                <td>{{ data_entry.data.power_factor|floatformat:2|default:"N/A" }}</td>
                                <td><span
                                        class="badge {% if data_entry.data.relay_state %}bg-success{% else %}bg-danger{% endif %}">
                                        {{ data_entry.data.relay_state|yesno:"ON,OFF"|default:"N/A" }}</span></td>
                                {% elif device.device_type == 'water_level' %}
                                <td>{{ data_entry.data.water_level|floatformat:2|default:"N/A" }}</td>
                                {% else %}
                                <td>{{ data_entry.data|default:"N/A" }}</td> {# Display raw dict if no specific fields
                                #}
                                {% endif %}
                            </tr>
                            {% empty %}
                            <tr>
                                <td colspan="8" class="text-center">No sensor data available for this device.</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %} {# Ensure this block name matches your base.html #}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const deviceId = "{{ device.id }}";
        const deviceType = "{{ device.device_type }}";
        let sensorChartInstance = null; // To store chart instance and destroy/recreate

        // Function to render the Chart.js graph
        function renderChart(dataPoints, predictions, anomalies, type) {
            const ctx = document.getElementById('sensorDataChart')?.getContext('2d');
            if (!ctx) {
                console.error("Canvas element 'sensorDataChart' not found!");
                return;
            }

            // Destroy existing chart if it exists to prevent overlap
            if (sensorChartInstance) {
                sensorChartInstance.destroy();
            }

            // Combine historical and predicted timestamps for x-axis labels (sorted uniquely)
            const allLabels = [...dataPoints.map(p => p.timestamp), ...predictions.map(p => p.timestamp)];
            const uniqueSortedLabels = [...new Set(allLabels)].sort();

            let datasets = [];
            let chartTitle = "Sensor Data Trends";
            let yAxisLabel = "Value";

            if (type === 'power_monitor') {
                chartTitle = "Power Monitor Metrics & Forecast";
                yAxisLabel = "Measurement";

                // Historical Data
                datasets.push({
                    label: 'Power (W)',
                    data: dataPoints.map(p => ({ x: p.timestamp, y: p.data.power })),
                    borderColor: 'rgb(75, 192, 192)', // Teal
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.2, // Slightly smoother curves
                    fill: false,
                    pointRadius: 3, // Make points visible
                    pointBackgroundColor: 'rgb(75, 192, 192)',
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Voltage (V)',
                    data: dataPoints.map(p => ({ x: p.timestamp, y: p.data.voltage })),
                    borderColor: 'rgb(255, 99, 132)', // Red
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    tension: 0.2,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgb(255, 99, 132)',
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Current (A)',
                    data: dataPoints.map(p => ({ x: p.timestamp, y: p.data.current })),
                    borderColor: 'rgb(54, 162, 235)', // Blue
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    tension: 0.2,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgb(54, 162, 235)',
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Energy (kWh)',
                    data: dataPoints.map(p => ({ x: p.timestamp, y: p.data.energy })),
                    borderColor: 'rgb(201, 203, 207)', // Grey
                    backgroundColor: 'rgba(201, 203, 207, 0.2)',
                    tension: 0.2,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgb(201, 203, 207)',
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Frequency (Hz)',
                    data: dataPoints.map(p => ({ x: p.timestamp, y: p.data.frequency })),
                    borderColor: 'rgb(255, 205, 86)', // Yellow
                    backgroundColor: 'rgba(255, 205, 86, 0.2)',
                    tension: 0.2,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgb(255, 205, 86)',
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Power Factor',
                    data: dataPoints.map(p => ({ x: p.timestamp, y: p.data.power_factor })),
                    borderColor: 'rgb(153, 102, 255)', // Purple
                    backgroundColor: 'rgba(153, 102, 255, 0.2)',
                    tension: 0.2,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgb(153, 102, 255)',
                    yAxisID: 'y'
                });

                // Anomalies (Power)
                const powerAnomalies = anomalies
                    .filter(a => a.metric === 'power')
                    .map(a => ({ x: a.timestamp, y: a.value }));
                if (powerAnomalies.length > 0) {
                    datasets.push({
                        label: 'Power Anomalies',
                        data: powerAnomalies,
                        pointBackgroundColor: 'rgb(255, 0, 0)', // Bright Red for anomalies
                        pointBorderColor: 'rgb(255, 255, 255)',
                        pointBorderWidth: 2,
                        pointRadius: 8, // Larger radius to stand out
                        pointHoverRadius: 10,
                        showLine: false, // Don't connect anomaly points
                        type: 'scatter', // Render as individual points
                        yAxisID: 'y'
                    });
                }

                // Predictions (Power)
                if (predictions.length > 0) {
                    datasets.push({
                        label: 'Predicted Power (W)',
                        data: predictions.map(p => ({ x: p.timestamp, y: p.predicted_power })),
                        borderColor: 'rgb(0, 200, 0)', // Green for predictions
                        backgroundColor: 'rgba(0, 200, 0, 0.2)',
                        borderDash: [5, 5], // Dotted line for prediction
                        tension: 0.2,
                        fill: false,
                        pointRadius: 0, // No points on prediction line
                        yAxisID: 'y'
                    });
                    // Prediction Bounds
                    datasets.push({
                        label: 'Prediction Upper Bound',
                        data: predictions.map(p => ({ x: p.timestamp, y: p.upper_bound })),
                        borderColor: 'transparent',
                        backgroundColor: 'rgba(0, 200, 0, 0.1)', // Light green fill for bounds
                        fill: '-1', // Fill area between this and the previous dataset (lower bound)
                        pointRadius: 0,
                        borderWidth: 0,
                        showLine: false,
                        yAxisID: 'y'
                    });
                    datasets.push({
                        label: 'Prediction Lower Bound',
                        data: predictions.map(p => ({ x: p.timestamp, y: p.lower_bound })),
                        borderColor: 'transparent',
                        backgroundColor: 'transparent', // This ensures fill is only above lower bound
                        fill: false, // Important to prevent filling downwards
                        pointRadius: 0,
                        borderWidth: 0,
                        showLine: false,
                        yAxisID: 'y'
                    });
                }

            } else if (type === 'water_level') {
                chartTitle = "Water Level History & Forecast";
                yAxisLabel = "Water Level (%)";

                datasets.push({
                    label: 'Water Level (%)',
                    data: dataPoints.map(p => ({ x: p.timestamp, y: p.data.water_level })),
                    borderColor: 'rgb(0, 123, 255)',
                    backgroundColor: 'rgba(0, 123, 255, 0.2)',
                    tension: 0.2,
                    fill: true, // Fill for water level makes sense
                    pointRadius: 3,
                    pointBackgroundColor: 'rgb(0, 123, 255)',
                    yAxisID: 'y'
                });

                // Anomalies (Water Level)
                const waterLevelAnomalies = anomalies
                    .filter(a => a.metric === 'water_level')
                    .map(a => ({ x: a.timestamp, y: a.value }));
                if (waterLevelAnomalies.length > 0) {
                    datasets.push({
                        label: 'Water Level Anomalies',
                        data: waterLevelAnomalies,
                        pointBackgroundColor: 'rgb(255, 0, 0)', // Bright Red
                        pointBorderColor: 'rgb(255, 255, 255)',
                        pointBorderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        showLine: false,
                        type: 'scatter',
                        yAxisID: 'y'
                    });
                }

                // Predictions (Water Level)
                if (predictions.length > 0) {
                    datasets.push({
                        label: 'Predicted Water Level (%)',
                        data: predictions.map(p => ({ x: p.timestamp, y: p.predicted_water_level })),
                        borderColor: 'rgb(123, 0, 255)', // Purple for predictions
                        backgroundColor: 'rgba(123, 0, 255, 0.2)',
                        borderDash: [5, 5],
                        tension: 0.2,
                        fill: false,
                        pointRadius: 0,
                        yAxisID: 'y'
                    });
                    // Prediction Bounds
                    datasets.push({
                        label: 'Prediction Upper Bound',
                        data: predictions.map(p => ({ x: p.timestamp, y: p.upper_bound })),
                        borderColor: 'transparent',
                        backgroundColor: 'rgba(123, 0, 255, 0.1)', // Light purple fill for bounds
                        fill: '-1',
                        pointRadius: 0,
                        borderWidth: 0,
                        showLine: false,
                        yAxisID: 'y'
                    });
                    datasets.push({
                        label: 'Prediction Lower Bound',
                        data: predictions.map(p => ({ x: p.timestamp, y: p.lower_bound })),
                        borderColor: 'transparent',
                        backgroundColor: 'transparent', // This ensures fill is only above lower bound
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 0,
                        showLine: false,
                        yAxisID: 'y'
                    });
                }
            } else {
                // If device type not specifically handled, provide a fallback message on canvas
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.font = '18px Inter, sans-serif';
                ctx.fillStyle = 'var(--muted-foreground)';
                ctx.textAlign = 'center';
                ctx.fillText('Analysis not available for this device type.', ctx.canvas.width / 2, ctx.canvas.height / 2);
                return; // Exit if no chart can be rendered
            }

            // Create the chart
            sensorChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    // Chart.js `time` scale handles parsing ISO strings directly; no need for `toLocaleTimeString` here
                    labels: uniqueSortedLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index', // Allows hovering over multiple datasets at a point
                        intersect: false, // Ensures tooltip shows even if not directly over a point
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle,
                            color: 'var(--foreground)',
                            font: {
                                size: 18,
                                family: 'Orbitron',
                                weight: 'bold'
                            }
                        },
                        legend: {
                            labels: {
                                color: 'var(--muted-foreground)',
                                font: {
                                    size: 14
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(44, 62, 80, 0.9)', // Darker, more opaque tooltip
                            titleColor: '#e0e0e0',
                            bodyColor: '#e0e0e0',
                            borderColor: 'var(--primary)',
                            borderWidth: 1,
                            cornerRadius: 6,
                            padding: 10,
                            callbacks: {
                                title: function (context) {
                                    // Display full timestamp in tooltip title
                                    return Luxon.DateTime.fromISO(context[0].label).toLocaleString(Luxon.DateTime.DATETIME_FULL);
                                },
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    // Check if context.parsed.y is a valid number before formatting
                                    if (typeof context.parsed.y === 'number' && !isNaN(context.parsed.y)) {
                                        label += context.parsed.y.toFixed(2); // Format numerical values
                                    } else {
                                        label += 'N/A';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                tooltipFormat: 'MMM d, yyyy h:mm:ss a', // Detailed tooltip
                                displayFormats: {
                                    hour: 'h:mm a', // Display hour and minute on axis
                                    day: 'MMM d',   // Display day for longer ranges
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                color: 'var(--muted-foreground)',
                                font: { size: 16 }
                            },
                            ticks: {
                                color: 'var(--muted-foreground)'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.08)' // Brighter grid lines
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: yAxisLabel, // Dynamic Y-axis label
                                color: 'var(--muted-foreground)',
                                font: { size: 16 }
                            },
                            ticks: {
                                color: 'var(--muted-foreground)'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.08)' // Brighter grid lines
                            }
                        }
                    }
                }
            });
        }

        // Function to render suggestions
        function renderSuggestions(suggestions) {
            const suggestionsListDiv = document.getElementById('suggestionsList');
            if (suggestionsListDiv) {
                suggestionsListDiv.innerHTML = ''; // Clear previous suggestions

                if (!suggestions || suggestions.length === 0 || (suggestions.length === 1 && suggestions[0].includes("No data to analyze"))) {
                    suggestionsListDiv.innerHTML = `
                        <div class="suggestion-item">
                            <svg class="suggestion-icon lucide lucide-check-circle" style="color: var(--accent);"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="m9.2 10.2 3 3L22 3"/></svg>
                            <p class="suggestion-text">Everything looks normal. No specific suggestions at this time.</p>
                        </div>`
                        ;
                } else {
                    suggestions.forEach(s => {
                        let iconSvg = '';
                        let textColor = 'var(--foreground)'; // Default text color

                        // Determine icon and text color based on suggestion content
                        if (s.includes("Anomaly") || s.includes("spike") || s.includes("critically low") || s.includes("very high") || s.includes("üö®")) {
                            iconSvg = `<svg class="suggestion-icon lucide lucide-alert-triangle" style="color: var(--destructive);"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>`;
                            textColor = 'var(--destructive)';
                        } else if (s.includes("Could not run") || s.includes("Not enough diverse data") || s.includes("‚ö†Ô∏è")) {
                            iconSvg = `<svg class="suggestion-icon lucide lucide-frown" style="color: var(--warning);"><circle cx="12" cy="12" r="10"/><path d="M16 16s-1.5-2-4-2-4 2-4 2"/><path d="M9 9h.01"/><path d="M15 9h.01"/></svg>`;
                            textColor = 'var(--warning)';
                        }
                        else if (s.includes("optimize usage") || s.includes("forecast looks normal") || s.includes("stable") || s.includes("‚úÖ") || s.includes("üí°")) {
                            iconSvg = `<svg class="suggestion-icon lucide lucide-bar-chart" style="color: var(--primary);"><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></svg>`;
                            textColor = 'var(--primary)'; // Changed to primary for positive suggestions
                        } else if (s.includes("low water") || s.includes("refilling")) {
                            iconSvg = `<svg class="suggestion-icon lucide lucide-droplet-half" style="color: var(--destructive);"><path d="M12 2v20c-3.5-1.5-6-4-6-8 0-4.8 2.6-7.8 6-10z"/></svg>`;
                            textColor = 'var(--destructive)';
                        } else if (s.includes("high water") || s.includes("overflow")) {
                            iconSvg = `<svg class="suggestion-icon lucide lucide-droplet" style="color: var(--warning);"><path d="M12 2.69V20a2 2 0 0 0 2 2c1.66 0 2-1.34 2-2 0-1.85-1.33-2.5-2-3.62L10 14a2 2 0 0 1-2-2V6.15c0-1.78 1.06-2.09 2-2.09 1.55 0 2 1.98 2 3.15Z"/></svg>`;
                            textColor = 'var(--warning)';
                        } else {
                            iconSvg = `<svg class="suggestion-icon lucide lucide-info" style="color: var(--accent);"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>`; // Default info icon
                            textColor = 'var(--foreground)';
                        }

                        const suggestionItem = document.createElement('div');
                        suggestionItem.className = 'suggestion-item';
                        suggestionItem.innerHTML = `
                            ${iconSvg}
                            <p class="suggestion-text" style="color: ${textColor};">${s}</p>
                        `;
                        suggestionsListDiv.appendChild(suggestionItem);
                    });
                }
            }
        }

        // Function to fetch and render historical data, predictions, anomalies, and suggestions
        async function fetchAndRenderAnalysis() {
            // Show loading state for suggestions
            const suggestionsListDiv = document.getElementById('suggestionsList');
            if (suggestionsListDiv) {
                suggestionsListDiv.innerHTML = `
                    <div class="suggestion-item">
                        <svg class="suggestion-icon lucide lucide-loader-2 animate-spin"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>
                        <p class="suggestion-text">Loading analysis data and suggestions...</p>
                    </div>
                `;
            }

            try {
                // *** THIS IS THE CRUCIAL CHANGE: Matching the backend URL structure ***
                const apiUrl = `/api/v1/device/${deviceId}/analysis/?duration=24h`;
                const response = await fetch(apiUrl);

                // --- DEBUGGING: Check network response ---
                console.log(`Fetching analysis data from: ${apiUrl}`);
                console.log('Response status:', response.status);
                // --- END DEBUGGING ---

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                // --- DEBUGGING: Log the full data object received from the API for analysis ---
                console.log('Received analysis data:', data);
                // --- END DEBUGGING ---

                // Render Chart if data points are available
                if (data.data_points && data.data_points.length > 0) {
                    renderChart(data.data_points, data.predictions || [], data.anomalies || [], deviceType);
                } else {
                    // If no data points, clear chart and show no data message on canvas
                    if (sensorChartInstance) {
                        sensorChartInstance.destroy();
                        sensorChartInstance = null;
                    }
                    const ctx = document.getElementById('sensorDataChart')?.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                        ctx.font = '18px Inter, sans-serif';
                        ctx.fillStyle = 'var(--muted-foreground)';
                        ctx.textAlign = 'center';
                        ctx.fillText('No sensor data available for charting in this period.', ctx.canvas.width / 2, ctx.canvas.height / 2);
                    }
                }

                // Render Suggestions
                renderSuggestions(data.suggestions || []);

                // The table is rendered by Django, so no JavaScript rendering for the table is needed here.

            } catch (error) {
                console.error(`Error fetching analysis data for device ${deviceId}:`, error);
                // Display error message to user in suggestions box and chart area
                const suggestionsListDiv = document.getElementById('suggestionsList');
                if (suggestionsListDiv) {
                    suggestionsListDiv.innerHTML = `
                        <div class="suggestion-item" style="color: var(--destructive);">
                            <svg class="suggestion-icon lucide lucide-x-octagon"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg>
                            <p class="suggestion-text">Error loading analysis: ${error.message}. Please try again later.</p>
                        </div>
                    `;
                }
                if (sensorChartInstance) {
                    sensorChartInstance.destroy();
                    sensorChartInstance = null;
                }
                const ctx = document.getElementById('sensorDataChart')?.getContext('2d');
                if (ctx) {
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    ctx.font = '18px Inter, sans-serif';
                    ctx.fillStyle = 'var(--destructive)';
                    ctx.textAlign = 'center';
                    ctx.fillText('Error loading chart data.', ctx.canvas.width / 2, ctx.canvas.height / 2);
                }
            }
        }

        // Initial fetch and render when the page loads
        fetchAndRenderAnalysis();

        // Optional: Periodically refresh analysis (be mindful of server load)
        setInterval(fetchAndRenderAnalysis, 15000); // Refresh every minute (60 seconds)
    });
</script>
{% endblock %}